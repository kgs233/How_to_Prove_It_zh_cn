#import "../lib.typ": *

== 演绎推理与逻辑联结词

如我们在引言中所述，证明在数学中扮演着核心角色，而演绎推理是证明的基础。
因此，我们通过探讨演绎推理的运作方式，来开启对数学推理与证明的研究。

=== 以下是三个演绎推理的例子

+ 明天要么下雨，要么下雪。 \
  现在太暖和了，不会下雪。 \
  因此，明天会下雨。

+ 如果今天是星期日，那么我今天不用上班。 \
  今天是星期日。 \
  因此，我今天不用上班。

+ 我明天或今天会去上班。 \
  我今天要待在家里。 \
  因此，我明天要去上班。
#linebreak()

在每种情况下，我们都是基于某些其他陈述（称为前提）为真的假设得出结论的。
例如，论点3中的前提是陈述“我明天或今天会去上班”
和“我今天要待在家里”。结论是“我明天会去上班”，
而这个结论似乎在某种程度上是由前提强加给我们的。

在每种情况下，我们都是基于某些其他陈述（称为前提）为真的假设得出结论的。例如，论点3中的前提是陈述“我明天或今天会去上班”
和“我今天要待在家里”。结论是“我明天会去上班”，似乎是某种程度上被前提所决定的。
但这个结论真的正确吗？毕竟，难道不存在这样的可能性：我今天待在家里，明天醒来生病，结果又得待在家里？
如果这种情况发生，结论就会被证明是错误的。但请注意，在这种情况下，
第一个前提⸺即“我明天或今天会去上班”⸺也会是错误的！虽然我们无法保证
结论是正确的，但结论只有在至少一个前提也是错误的情况下才会错误。如果两个前提都是正确的，我们可以确定结论也是正确的。
这就是结论被前提所决定的含义，这也是我们用来判断演绎推理正确性的标准。
我们将说一个论点是_有效的（valid）_，如果前提为假结论必定为假。我们例子中的三个论点都是有效的论点。

以下是一个无效的演绎推理的例子： \

#textbox[
  要么是管家有罪，要么是女仆有罪。\
  要么是女仆有罪，要么是厨师有罪。 \
  因此，要么是管家有罪，要么是厨师有罪。
] \
该论证无效，因为即使两个前提均为真，结论也可能为假。例如，
如果女仆有罪，但管家和厨师均无罪，那么两个前提均为真，但结
论为假。

我们可以通过比较例1.1.1中的三个论点，来了解什么使一个论点有效。
表面上看，论点2和3似乎最有共同点，因为它们都涉及同一个主题：
工作出勤率。但在推理方式上，
论点1和3最为相似。它们都在第一个前提中提出两种可能性，用第二个前提排除第二种可能性，
然后得出第一种可能性必然成立的结论。换言之，这两个论点都具有
以下形式： \

#textbox[
  $P$ 或 $Q$ \
  非 $Q$ \
  因此 $P$
] \
正是这种形式，而非论题内容，使得这些论证成立。
你可以通过将字母 $P$ 视为陈述“明天会下雨”，
而 $Q$ 视为“明天会下雪”来看到论证1具有这种形式。
对于论证3，$P$ 将是“我明天会去上班”，而Q将是“我今天会去上班”。

将每个论点中的某些陈述替换为字母，正如我们在
陈述论点 $1$ 和 $3$ 的形式时所做的那样，有两个优点。首先，它使我们
不会被那些不影响论点有效性的论点细节所分散注意力。
你无需了解天气预报或工作习惯，
就能识别出论点 $1$ 和 $3$是 有效的。这是因为这两个论点都
具有之前展示的形式，而你可以判断这种论点形式是有效的，即使你不知道 $P$ 和 $Q$ 代表什么。如果你不相信这一点，请考虑以下论点：

#textbox[
  要么是framger小工具出现故障，要么是wrompal机制未对齐。 \
  我已检查过wrompal机制的对齐情况，一切正常。 \
  因此，framger小工具出现故障。
] \
如果一位技师在检查你的车后给出这样的解释，你可能仍然对为什么车打不着火感到困惑，但你理解他的逻辑不会有任何困难！

更重要的是，我们对论证1和论证3形式的分析阐明了决定其有效性的关键：即_“或”（or）_和_“非”（not）_这两个词。在大多数演绎推理中，尤其是在数学推理中，仅仅几个词的含义便能为我们理解推理的有效性或无效性提供关键。（在例1.1.1中的论证2中，哪些词是重要的？）本书的前几章致力于研究这些词语及其在数学写作和推理中的应用。

在本章中，我们将重点讨论用于将陈述句组合成更复杂句子的词汇。我们将继续使用字母来代表陈述，
但仅限于那些明确的陈述，即要么为真要么为假的陈述。疑问句、感叹句以及模糊的陈述将不被允许。
使用符号（有时称为_联结呼号（connective symbols）_）来代表一些用于连接陈述的词汇也将是有用的。
以下是我们前三个联结符号及其代表的词汇：

#align(center)[
  #grid(
    columns: 2,
    column-gutter: 3em,

    table(
      columns: 1,
      table.header([符号]),
      $or$,
      $and$,
      $not$,
    ),
    table(
      columns: 1,
      table.header([含义]),
      [或],
      [与],
      [非],
    ),
  )
]

因此，如果 $P$ 和 $Q$ 分别代表两个命题，那么我们将用 $P or Q$ 表示
“ $P$ 或 $Q$ ”这一命题，用 $P and Q$ 表示“ $P$ 且 $Q$ ”，用 $not P$ 表示“非 $P$ ”或
“ $P$ 为假”。命题 $P or Q$ 有时被称为 $P$ 和 $Q$ 的析取，$P and Q$ 被称为 $P$ 和 $Q$ 的合取，而 $not P$ 被称为 $P$ 的否定。

=== 分析以下陈述的逻辑形式：

+ 约翰去了商店，或者我们没有鸡蛋了。
+ 乔会离家并且不会回来了。
+ 要么比尔在工作而简不在，要么简在工作而比尔不在。

_解_
#textbox[
  + 如果我们用 $P$ 表示陈述“约翰去了商店”，用 $Q$ 表示“我们没有鸡蛋了”，那么这个陈述可以用符号表示为 $P or Q$ 。
  + 如果我们用 $P$ 表示“乔要离开家”这一陈述，用 $Q$ 表示“乔不会回来”，那么我们可以将这一陈述符号表示为 $P and Q$ 。但这种分析忽略了该陈述的一个重要特征，因为它没有表明 $Q$ 是一个否定陈述。我们可以通过让 $R$ 代表陈述“乔将回来”，然后将陈述 $Q$ 写为 $not R$ 来获得更好的分析。将此代入我们对原陈述的首次分析中，我们得到改进的分析 $P and not R)$ 。
  + 令 $B$ 表示陈述“比尔在上班”，令 $J$ 表示陈述“简在上班”。那么陈述的前半部分“比尔在上班而简不在”可以用 $B and not J$ 来表示。同样，后半部分是 $J and not B$ 。要表示整个陈述，我们必须用或运算将这两个陈述结合起来，形成它们的析取，因此答案是 $( B and not J ) or ( J and not B )$。
]

请注意，在分析前例中的第三个陈述时，我们在形成 $B and not J$与$J and not B$的析取式时添加了括号，以明确表示哪些陈述被组合在一起。
这类似于代数中使用括号的情况，例如，$a + b$ 和 $a - b$ 的乘积将写为 $(a + b) dot (a - b)$ ，括号用于明确表示哪些量需要相乘。
与代数类似，在逻辑中，为了使表达式更简洁易读，有时可以省略部分括号。
然而，我们必须就如何阅读此类表达式达成一些约定，以确保它们仍然不存在歧义。
其中一个约定是，not 符号始终仅适用于紧跟其后的陈述。
例如，$not P and Q$ 表示 $(not P) and Q$ ，而非 $not (P and Q)$ 。
我们将在后文讨论关于括号的其他约定。

=== 以下表达式分别对应哪些中文句子？

+ $(not S and  L)or S$ ，其中 $S$ 表示“约翰很愚蠢”，$L$ 表示“约翰很懒惰”。
+ $not S and (L or S)$ ，其中 $S$ 和 $L$ 与之前相同。
+ $not (S and L)or S$ ，其中S和L仍与之前相同。

_解_

+ 约翰要么不傻，只是懒惰，要么就是傻。
+ 约翰不是笨蛋，要么他很懒惰，要么他就是个笨蛋。注意中文中“要么”这个词的位置会根据括号的位置而变化。
+ 约翰不是既笨又懒，要么他就是个笨蛋。中文中的“既”这个词也帮助区分括号的不同可能位置。